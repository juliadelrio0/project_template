---
title: "analisis_grafo"
author: "Javier Méndez"
date: "2024-11-05"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


 
# Carga de datos

En primer lugar importamos las librerias y cargamos los datos necesarios para construir el grafo dirigido (nodos y aristas).
```{r}
library(igraph)

#Cargamos nodos
nodos <- read.csv("", header=T, as.is=T)

#Cargamos aristas
aristas <- read.csv("", header=T, as.is=T)

#Generamos el grafo dirigido con lo anterior
net <- graph_from_data_frame(d=aristas, vertices=nodos, directed=T)

#Representación de prueba (jugar con parametros)
plot(net, edge.arrow.size=.4, edge.curved=0.1, vertex.color="white",
     vertex.frame.color="black", vertex.label=V(net)$media, vertex.label.color="black",   vertex.label.cex=.7)

```


# Grafos expresivos

```{r}
# Por color
colors <- c("gray50", "tomato", "gold")
V(net)$color <- colors[V(net)$media.type]
plot(net, edge.arrow.size=.4)

#Tamaño proporcional al parametro audiencia con leyenda
V(net)$size <- V(net)$audience.size*0.7
plot(net, edge.arrow.size=.4, vertex.label=NA)
legend(x=-1.5, y=-1.1, c("Newspaper","Television", "Online News"), pch=21,
       col="#777777", pt.bg=colors, pt.cex=2, cex=.8, bty="n", ncol=3)

#Grafo cuyos nodos son los nombres en negrita
plot(net, vertex.shape="none", edge.arrow.size=0.4, vertex.label=V(net)$media, 
     vertex.label.font=2, vertex.label.color="gray40", vertex.label.cex=.7, 
     edge.color="gray85")


#grafo recomendado por igraph
plot(net, edge.arrow.size=0.4, layout=layout_nicely)
```



#Usamos igraph

```{r}
#probar grafos para ver cual me quedo
layouts <- grep("^layout_", ls("package:igraph"), value=TRUE)[-1] 

par(mfrow=c(3,3), mar=c(1,1,1,1))
for (layout in layouts) {
  print(layout)
  l <- do.call(layout, list(net)) 
  plot(net, edge.arrow.size=0.4, edge.arrow.mode=0, layout=l, main=layout)
}
```

#distribucion de adyacencia
```{r}
#cambiar por un plot de los pesos de aristas
plot(x = 0:(length(deg.dist)-1),y = 1 - deg.dist, pch = 19, cex = 1.2,col = "orange", xlab = "Degree", ylab = "Cumulative Frequency")

#plot del grafo segun el grado de los nodos
deg <- degree(net, mode = "all")
plot(net, vertex.size = deg * 3)

#histograma del grado de los nodos
hist(deg, breaks = 1:vcount(net) - 1, main = "Histograma del grado de los nodos")


#represenación alternativa con mapa de calor
netm <- get.adjacency(net, attr="weight", sparse=F)
colnames(netm) <- V(net)$media
rownames(netm) <- V(net)$media
palf <- colorRampPalette(c("gold", "dark orange")) 
heatmap(netm[,17:1], Rowv = NA, Colv = NA, col = palf(100),scale="none", 
        margins=c(10,10))
```

#Camino mas corto entre 2 genes
```{r}
news.path <- shortest_paths(net, from = V(net)[media=="MSNBC"], to  = V(net)[media=="New York Post"],output = "both")
ecol <- rep("gray80", ecount(net))
ecol[unlist(news.path$epath)] <- "orange"
ew <- rep(2, ecount(net))
ew[unlist(news.path$epath)] <- 4
vcol <- rep("gray40", vcount(net))
vcol[unlist(news.path$vpath)] <- "gold"
plot(net, vertex.color=vcol, edge.arrow.size=0.4, edge.color=ecol, edge.width=ew, edge.arrow.mode=0)
```



# deteccion de comunidades{.tabset}

## Intermediación de nodos

```{r intermediacion}

community <- cluster_edge_betweenness(net) 
dendPlot(community, mode = "hclust") 

#represenciacion de clusteres en la red
plot(community, net)

## Cuantas comunidades ha encontrado? 
length(community)

# ¿A que comiunidad pertenece cada nodo?
membership(community)
```

##Optimización voraz
```{r voraz}

#ignoraremos la direccionalidad del grafo
cfg <- cluster_fast_greedy(as.undirected(net)) 
plot(cfg, as.undirected(net))
```

##propagación de etiquetas

```{r}
clp <- cluster_label_prop(net) 
plot(clp, net)
```

##grafo con nodos coloreados por comunidad
```{r}
V(net)$community <- cfg$membership 
colrs <- adjustcolor(c("gray50", "tomato", "gold", "yellowgreen"), alpha = .6)
plot(net, vertex.color = colrs[V(net)$community])
```


#Identificacion de nodos relevantes con K-Core

```{r k-core}
kc <- coreness(net, mode = "all") 
plot( net, vertex.size = kc * 6, vertex.label = kc, vertex.color = colors[kc] )
```

# Assortativity

## Asortatividad nominal (categoricas)

```{r asort_nominal}
assortativity_nominal(net, V(net)$media.type, directed = F)
```

## Asortatividad ordinal (numericas)

```{r asort_ordinal}
assortativity(net, V(net)$audience.size, directed = F)
```

## Asortatividad por grado
```{r asort_grado}
assortativity_degree(net, directed = F)
```


```

